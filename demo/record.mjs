import http from 'node:http';
import fs from 'node:fs';
import path from 'node:path';
import { spawnSync } from 'node:child_process';
import { fileURLToPath } from 'node:url';

import { VARIANTS } from './variants.js';

// Usage:
//   cd demo
//   npm i
//   npx playwright install chromium
//   npm run record              # writes demo/output/microemployee-demo.*
//   npm run record:all          # writes demo/output/variants/microemployee-<variant>.*
//
// Flags:
//   node record.mjs --variant v03-pr-review
//   node record.mjs --all [--gif]

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const root = __dirname;

function parseArgs(argv) {
  const out = { all: false, gif: false, variant: null };
  for (let i = 0; i < argv.length; i++) {
    const a = argv[i];
    if (a === '--all') out.all = true;
    else if (a === '--gif') out.gif = true;
    else if (a === '--variant') out.variant = argv[++i] || null;
    else if (a.startsWith('--variant=')) out.variant = a.split('=')[1] || null;
  }
  return out;
}

function serveFile(reqPath, res) {
  const safe = String(reqPath || '/').replace(/\\/g, '/').split('?')[0];
  const rel = safe === '/' ? '/index.html' : safe;
  const full = path.join(root, rel);
  if (!full.startsWith(root)) {
    res.writeHead(403);
    res.end('forbidden');
    return;
  }
  if (!fs.existsSync(full) || fs.statSync(full).isDirectory()) {
    res.writeHead(404);
    res.end('not found');
    return;
  }
  const ext = path.extname(full).toLowerCase();
  const contentType =
    ext === '.html'
      ? 'text/html; charset=utf-8'
      : ext === '.css'
        ? 'text/css; charset=utf-8'
        : ext === '.js'
          ? 'text/javascript; charset=utf-8'
          : 'application/octet-stream';
  res.writeHead(200, { 'content-type': contentType });
  fs.createReadStream(full).pipe(res);
}

function findFfmpeg() {
  const candidates = ['ffmpeg', '/opt/homebrew/bin/ffmpeg', '/usr/local/bin/ffmpeg'];
  for (const c of candidates) {
    const r = spawnSync(c, ['-version'], { stdio: 'ignore' });
    if (r.status === 0) return c;
  }
  return null;
}

function newestWebmIn(dir) {
  const webms = fs
    .readdirSync(dir)
    .filter((f) => f.endsWith('.webm'))
    .map((f) => ({ f, mtime: fs.statSync(path.join(dir, f)).mtimeMs }))
    .sort((a, b) => b.mtime - a.mtime);
  if (webms.length === 0) return null;
  return path.join(dir, webms[0].f);
}

function writeGallery(outVariantsDir, variants, { hasGif }) {
  const rows = variants
    .map((v) => {
      const base = `microemployee-${v.id}`;
      const gif = hasGif ? `<a href="./${base}.gif">gif</a>` : '';
      return `
        <section class="card">
          <h2>${v.id}</h2>
          <p class="sub">${v.title}</p>
          <a class="thumb" href="./${base}.mp4"><img src="./${base}.png" alt="${v.id} thumbnail"></a>
          <div class="links">
            <a href="./${base}.mp4">mp4</a>
            <a href="./${base}.webm">webm</a>
            ${gif}
          </div>
          <video controls preload="metadata" width="960" src="./${base}.mp4"></video>
        </section>
      `;
    })
    .join('\n');

  const html = `<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MicroEmployee Demo Variants</title>
    <style>
      :root { color-scheme: light; }
      body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; background: #f6f6f6; color: #111; }
      .wrap { max-width: 1040px; margin: 0 auto; padding: 18px; }
      h1 { margin: 0 0 6px; font-size: 18px; }
      .hint { margin: 0 0 18px; color: rgba(0,0,0,0.62); font-size: 13px; }
      .grid { display: grid; gap: 14px; }
      .card { background: #fff; border: 1px solid rgba(0,0,0,0.10); border-radius: 12px; padding: 14px; box-shadow: 0 10px 30px rgba(0,0,0,0.06); }
      .sub { margin: 0 0 10px; color: rgba(0,0,0,0.62); font-size: 13px; }
      .thumb img { width: 100%; max-width: 960px; border-radius: 10px; border: 1px solid rgba(0,0,0,0.08); display: block; }
      .links { display: flex; gap: 10px; margin: 10px 0; font-size: 13px; }
      video { width: 100%; max-width: 960px; border-radius: 10px; border: 1px solid rgba(0,0,0,0.10); background: #000; }
      a { color: #1264a3; text-decoration: none; font-weight: 600; }
      a:hover { text-decoration: underline; }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>MicroEmployee Demo Variants</h1>
      <p class="hint">Generated by <code>demo/record.mjs --all</code></p>
      <div class="grid">
        ${rows}
      </div>
    </div>
  </body>
</html>`;
  fs.writeFileSync(path.join(outVariantsDir, 'index.html'), html, 'utf8');
}

async function main() {
  const { chromium } = await import('playwright');

  const args = parseArgs(process.argv.slice(2));

  const outDir = path.join(root, 'output');
  const rawDir = path.join(outDir, 'raw');
  fs.mkdirSync(rawDir, { recursive: true });

  const outVariantsDir = path.join(outDir, 'variants');
  const writeVariants = args.all || !!args.variant;
  if (writeVariants) fs.mkdirSync(outVariantsDir, { recursive: true });

  const ffmpeg = findFfmpeg();

  const pick = (id) => VARIANTS.find((v) => v.id === id) || VARIANTS[0];
  const selected = args.all ? VARIANTS : [pick(args.variant || 'v01-thread-recap')];

  const server = http.createServer((req, res) => serveFile(req.url || '/', res));
  await new Promise((resolve) => server.listen(0, '127.0.0.1', resolve));
  const addr = server.address();
  const port = typeof addr === 'object' && addr ? addr.port : 0;

  const browser = await chromium.launch({ headless: true });

  try {
    for (const v of selected) {
      const base = writeVariants ? `microemployee-${v.id}` : 'microemployee-demo';
      const outBaseDir = writeVariants ? outVariantsDir : outDir;

      const rawVariantDir = path.join(rawDir, v.id);
      fs.rmSync(rawVariantDir, { recursive: true, force: true });
      fs.mkdirSync(rawVariantDir, { recursive: true });

      const url = `http://127.0.0.1:${port}/index.html?autoplay=1&variant=${encodeURIComponent(
        v.id,
      )}`;

      const context = await browser.newContext({
        viewport: { width: 960, height: 540 },
        deviceScaleFactor: 2,
        recordVideo: { dir: rawVariantDir, size: { width: 960, height: 540 } },
      });

      const page = await context.newPage();
      page.on('pageerror', (err) => console.error('[pageerror]', err));
      page.on('requestfailed', (req) =>
        console.error('[requestfailed]', req.url(), req.failure()?.errorText),
      );

      await page.goto(url, { waitUntil: 'domcontentloaded' });
      await page.waitForFunction(() => window.__DEMO_READY__ === true, null, { timeout: 60_000 });
      await page.waitForFunction(() => window.__DEMO_DONE__ === true, null, { timeout: 120_000 });
      await page.waitForTimeout(600);

      await page.close();
      await context.close();

      const webmIn = newestWebmIn(rawVariantDir);
      if (!webmIn) throw new Error(`No webm produced for ${v.id}. Did Playwright record?`);

      const webmOut = path.join(outBaseDir, `${base}.webm`);
      fs.copyFileSync(webmIn, webmOut);

      if (!ffmpeg) continue;

      const mp4Out = path.join(outBaseDir, `${base}.mp4`);
      const thumbOut = path.join(outBaseDir, `${base}.png`);
      const gifOut = path.join(outBaseDir, `${base}.gif`);

      // MP4
      spawnSync(
        ffmpeg,
        [
          '-y',
          '-i',
          webmOut,
          '-an',
          '-c:v',
          'libx264',
          '-pix_fmt',
          'yuv420p',
          '-movflags',
          '+faststart',
          '-preset',
          'veryfast',
          '-crf',
          '23',
          mp4Out,
        ],
        { stdio: 'inherit' },
      );

      // Thumbnail (good for quickly scanning variants)
      spawnSync(
        ffmpeg,
        // Grab a frame near the end so it's likely to include the "final state" of the variant.
        ['-y', '-sseof', '-0.4', '-i', mp4Out, '-frames:v', '1', '-update', '1', thumbOut],
        { stdio: 'inherit' },
      );

      const wantGif = args.all ? args.gif : true;
      if (!wantGif) continue;

      // GIF (palette workflow for size/quality)
      const palette = path.join(outBaseDir, `${base}-palette.png`);
      spawnSync(
        ffmpeg,
        [
          '-y',
          '-i',
          webmOut,
          '-vf',
          'fps=12,scale=960:-1:flags=lanczos,palettegen=max_colors=96',
          '-frames:v',
          '1',
          '-update',
          '1',
          palette,
        ],
        { stdio: 'inherit' },
      );
      spawnSync(
        ffmpeg,
        [
          '-y',
          '-i',
          webmOut,
          '-i',
          palette,
          '-lavfi',
          'fps=12,scale=960:-1:flags=lanczos[x];[x][1:v]paletteuse=dither=bayer:bayer_scale=3',
          gifOut,
        ],
        { stdio: 'inherit' },
      );
      fs.existsSync(palette) && fs.unlinkSync(palette);
    }

    if (args.all) writeGallery(outVariantsDir, selected, { hasGif: args.gif && !!ffmpeg });
  } finally {
    await browser.close();
    server.close();
  }
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
